import Web3 from "web3";
import contractABI from './abi/MedicineCrateTracking.json';

// const contractAddress = process.env.NEXT_PUBLIC_CONRACT_ADDRESS_IN_SEPOLIA;
// const contractAddress = process.env.NEXT_PUBLIC_CONRACT_ADDRESS_IN_LOCAL;
// const contractAddress = process.env.VITE_REACT_APP_CONRACT_ADDRESS_IN_LOCAL;
// const contractAddress = import.meta.env.VITE_CONTRACT_ADDRESS_IN_LOCAL;
const contractAddress = process.env.NEXT_PUBLIC_CONRACT_ADDRESS_IN_LOCAL;



export async function debugIsExists(crateCode){
  try{
    const { web3, contract } = getWeb3AndContract();
    const account = await getAccount();
    console.log("Network ID:", await web3.eth.net.getId());
    console.log("Code at addr:", await web3.eth.getCode(contractAddress));
    const Tx =  await contract.methods.debugIsExists(
      crateCode, 
    ).call({from : account})
    console.log("debug crate code", Tx);
    return Tx;
  }catch(e){
    console.error("Error debug crate code", e)
    throw new Error(`Failed to debug crate code: ${e.message}`)
  }

}



// Helper functions: Get Web3 instance and contract (client-side only)
function getWeb3AndContract() {
  if (typeof window === 'undefined' || typeof window.ethereum === 'undefined') {
    throw new Error("Web3 not available - make sure this code runs on client side");
  }

  const web3 = new Web3(window.ethereum);
  
  if (!contractAddress) {
    throw new Error("Contract address not configured. Please check your environment variables.");
  }
  
  console.log("Contract Address:", contractAddress);
  console.log("Contract ABI loaded:", !!contractABI);
  
  const contract = new web3.eth.Contract(contractABI, contractAddress);
  return { web3, contract };
}

export async function getAccount() {
  try {
    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
    console.log("Connected account:", accounts[0]);
    return accounts[0];
  } catch (error) {
    console.error("Error getting account:", error);
    throw new Error("Failed to connect wallet. Please make sure MetaMask is installed and connected.");
  }
}

//Blockchain Read and Write Functions:

export async function registerCrate(crateCode, productID, medicineName, cidDocument, bottleCount, bottleIds ) {
  /* 
    1. Register a new crate

    params:
      string crateCode : manufacturer assigns crateCode
      string productID : productID of the medicine
      string medicineName : medicineName
      (removed) address manufacturerWalletAddress : wallet address of the manufacturer
      string cidDocument : the key which links to the manufacturer certificate in the DB
      uint256 bottleCount : number of bottles in the crate
      string [] bottleIds : list of all the bottle ids generated by the app
    
    returns:
      
  */
  try {
    console.log("Registering crate with parameters:", {
      crateCode,
      productID,
      medicineName,
      // manufacturerWalletAddress,
      cidDocument,
      bottleCount,
      bottleIdsLength: bottleIds?.length
    });

    const { contract } = getWeb3AndContract();
    const account = await getAccount();
    
    // Validate parameters
    if (!crateCode || !productID || !medicineName || !cidDocument || !bottleCount) {
      throw new Error("Missing required parameters for crate registration");
    }
    
    if (!bottleIds || bottleIds.length === 0) {
      throw new Error("BottleIds array cannot be empty");
    }
    
    if (bottleCount <= 0 || bottleCount > 99999) {
      throw new Error("Invalid bottle count");
    }

    console.log("Calling contract.registerCrate...");
    
    const Tx = await contract.methods.registerCrate(
      crateCode,
      productID,
      medicineName,
      // manufacturerWalletAddress,
      cidDocument,
      bottleCount,
      bottleIds
    ).send({ from: account });
    
    console.log("Crate registration successful:", Tx);
    return Tx;
  } catch (error) {
    console.error("Error registering crate:", error);
    
    // Provide more specific error messages
    if (error.message.includes("User denied")) {
      throw new Error("Transaction was rejected by user");
    } else if (error.message.includes("insufficient funds")) {
      throw new Error("Insufficient funds for transaction");
    } else if (error.message.includes("Crate already registered")) {
      throw new Error("Crate code already exists in the system");
    } else if (error.message.includes("execution reverted")) {
      throw new Error("Contract execution failed. Please check your parameters and try again.");
    } else {
      throw new Error(`Failed to register crate: ${error.message}`);
    }
  }
}

export async function createSubCrate(parentCrateCode, subCrateID, bottlesIDs){
  /* 
    2. Create new Sub Crate

    params:
      string parentCrateCode : Crate code of the crate you want to create sub crates of
      string subCrateID : The code you want to assign to the new sub crate
      string[] bottlesIDs : list of the code of bottles in the new sub crate
  */

  try{
    const { contract } = getWeb3AndContract();
    const account = await getAccount();
    const Tx =  await contract.methods.createSubCrate(
      parentCrateCode, 
      subCrateID, 
      bottlesIDs
    ).send({ from: account })
    console.log("successfully created a sub crate", Tx);
    return Tx;
  }catch(e){
    console.error("Error creating a sub crate", e)
    throw new Error(`Failed to create a sub crate: ${e.message}`)
  }
}



export async function sendCrate(parentCrateCode, receiverWalletAddress) {
  /* 
    3. Send crate to next holder

    params:
      string parentCrateCode : code of the crate you want to send
      address receiverWalletAddress : wallet address of the receiver
  */
  try {
    const { contract } = getWeb3AndContract();
    const account = await getAccount();
    const Tx =  await contract.methods.crateSend(
      parentCrateCode,
      receiverWalletAddress
    ).send({ from: account });
    console.log("successfully sent the crate", Tx)
    return Tx;
  } catch (error) {
    console.error("Error sending crate:", error);
    throw new Error(`Failed to send crate: ${error.message}`);
  }
}

export async function sendSubCrate(subCrateCode, receiverWalletAddress){
  /* 
    4. Send Sub Crate to the next holder

    params:
      string subCrateCode : code of the sub crate you want to send
      address receiverWalletAddress : sub crate reciver's wallet address
    */
  try{
    const { contract } = getWeb3AndContract();
    const account = await getAccount();
    const Tx = await contract.methods.subCrateSend(
      subCrateCode,
      receiverWalletAddress
    ).send({ from: account })
    console.log("successfully sent the sub crate", Tx);
    return Tx;
  }catch (error) {
    console.error("Error sending sub crate:", error);
    throw new Error(`Failed to send sub crate: ${error.message}`);
  }
}

export async function receiveCrate(crateCode) {
  /* 
    5. Receive crate by next holder

    params:
      string crateCode : The code of the crate to be received
  */
  try {
    const { contract } = getWeb3AndContract();
    const account = await getAccount();
    const Tx = await contract.methods.crateReceived(
      crateCode
    ).send({ from: account });
    console.log("successfully received crate", Tx , "by receiver : ", account)
  } catch (error) {
    console.error("Error receiving crate:", error);
    throw new Error(`Failed to receive crate: ${error.message}`);
  }
}

export async function retailerReceivedCrate(parentCrateCode) {
  /* 
    6. Mark crate as received by retailer (final destination)

    params:
      string crateCode : The code of crate to be received by the retailer only  
  */
  try {
    console.log("calling the retailerReceivedCrate api")
    const { contract } = getWeb3AndContract();
    const account = await getAccount();
    const Tx =  await contract.methods.crateRetailerReceived(
      parentCrateCode
    ).send({ from: account });
    console.log("successfully received crate", Tx , "by retail receiver : ", account)
    return Tx
  } catch (error) {
    console.error("Error marking crate as received by retailer:", error);
    throw new Error(`Failed to mark crate as received: ${error.message}`);
  }
}


export async function retailerReceivedSubCrate(subCrateCode){
  /* 
    7. Receive sub crate by the retailer

    params:
      string subCrateCode : crate code of the sub crate
  */
  try{
    const { contract } = getWeb3AndContract();
    const account = await getAccount();
    const Tx = await contract.methods.subCrateRetailerReceived(
      subCrateCode
    ).send({ from: account }) 
    console.log("successfully received sub crate", Tx , "by retail receiver : ", account);
    return Tx;
  }catch(error){
    console.error("Error marking crate as received by retailer:", error);
    throw new Error(`Failed to mark crate as received: ${error.message}`);
  }

}

export async function scanBottle(bottleCode){
  /* 
    8. Scan bottle to check if valid or not

    params:
      string bottleCode : unique bottle code
    
    returns:
      object : returns the Tx hash which contains the usefully returns isVaild(bool) 
               if true the bottle is valid if false the bottle has already been scanned

  */

  try{
    const { contract } = getWeb3AndContract();
    const account = await getAccount();
    const Tx = await contract.methods.scanBottle(
      bottleCode
    ).send({ from: account });
    console.log("scanned the bottle successfully (return may be true or false) : ", Tx);
    return Tx; // this doesnt directly return if the bottle is valid
  }catch(error){
    console.error("error scanning the bottle");
    throw new Error(`failed to scan the bottle ${error.message}`);
  }
}


//Blockchain Read only functions:

export async function getAllBottlesOfCrate(parentCrateCode){
  /* 
    8. Get all the bottles available to be made into sub crate

    params:
      string parentCrateCode : parentCrateCode
    
    returns:
      string[] : a list of all the available bottle codes

  */

  try{
    const { contract } = getWeb3AndContract();
    const account = await getAccount();
    const Tx = await contract.methods.getAllBottlesOfCrate(
      parentCrateCode
    ).call({ from: account });
    console.log("successfully retrived all bottleIds");
    return Tx; 
  }catch(error){
    console.error("error retriving the bottleIds");
    throw new Error(`failed to retrive the bottleIds ${error.message}`);
  }

}

//yet to be implemented functions:

export async function getAllCrates(){

}

export async function getAllSubCratesOfCrate(parentCrateCode){

}

export async function getCrateInfo(){

}


export async function getAllBottlesOfSubCrate(){

}




//Blockchain Pure functions:

